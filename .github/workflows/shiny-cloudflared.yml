name: Shiny Cloudflared Tunnel

on:
  workflow_dispatch:
    inputs:
      trigger:
        description: 'Trigger for manual run'
        required: true
        default: 'manual'

env:
  TUNNEL_TOKEN: ${{ secrets.TUNNEL_TOKEN }}
  #TUNNEL_ORIGIN_CERT: ${{ secrets.TUNNEL_ORIGIN_CERT }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/seqyuan/shiny:1.0
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          apt-get update
          apt-get install -y jq

      - name: Install cloudflared
        run: |
          wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          dpkg -i cloudflared-linux-amd64.deb
          rm cloudflared-linux-amd64.deb

      - name: Start Shiny app
        run: |
          R -e "shiny::runApp('app.R', port = 8082, host = '0.0.0.0')" &
          sleep 5  # Wait for Shiny to start

      - name: Start tunnel and get URL
        id: tunnel
        run: |
          # Start tunnel in background with token
          cloudflared tunnel run --token $TUNNEL_TOKEN --url http://localhost:8082 &
          sleep 10  # Wait for tunnel to establish
          
          # Get tunnel ID and URL
          TUNNEL_INFO=$(cloudflared tunnel list --token $TUNNEL_TOKEN | grep -v "NAME" | head -n 1)
          TUNNEL_ID=$(echo "$TUNNEL_INFO" | awk '{print $1}')
          TUNNEL_NAME=$(echo "$TUNNEL_INFO" | awk '{print $2}')
          
          echo "tunnel_id=$TUNNEL_ID" >> $GITHUB_OUTPUT
          echo "tunnel_name=$TUNNEL_NAME" >> $GITHUB_OUTPUT
          
          # Get tunnel URL using the tunnel name
          TUNNEL_URL=$(cloudflared tunnel info $TUNNEL_NAME --token $TUNNEL_TOKEN | grep -oP '(?<=url=)[^ ]+')
          echo "tunnel_url=$TUNNEL_URL" >> $GITHUB_OUTPUT
          
          # Display tunnel information
          echo "Tunnel ID: $TUNNEL_ID"
          echo "Tunnel Name: $TUNNEL_NAME"
          echo "Tunnel URL: $TUNNEL_URL"
          
          # Keep the workflow running
          tail -f /dev/null 